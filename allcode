#include "shell.h"
#include "utils.h"
#include <sys/wait.h>
#include <string.h>

/**
 * run_command - A function that executes a user's command.
 * @command: The command to run or execute.
 * @args: List of arguments for the new process.
 * @envp: List of environment variables.
 *
 * Return: 1 for errors and 0 to to ascertain success.
 */

void run_command(const char *command, char **args, char **envp)
{
	pid_t child_pid;

	if (command == NULL)
	{
		perror(args[0]);
		return;
	}

	child_pid = fork();

	if (child_pid == -1)
	{
		perror("fork");
		exit(EXIT_FAILURE);
	}
	else if (child_pid == 0)
	{
		execve(command, args, envp);
		perror(command);
		exit(EXIT_FAILURE);
	}
	else
	{
		wait(NULL);
	}
}
#include "shell.h"
#include "utils.h"

/**
 * main - Entry point of the shell program.
 *
 * Return: Always returns 0.
 */

int main(void)
{
	char *raw_user_input = malloc(MAX_CMD_LEN);
	char *command = malloc(MAX_CMD_LEN);
	char **args;

	if (raw_user_input == NULL || command == NULL)
		exit(EXIT_FAILURE);

	while (1)
	{
		size_t i = 0;

		read_input(raw_user_input, MAX_CMD_LEN);
		args = get_args(raw_user_input);

		command = prepare(args[0]);

		run_command(command, args, environ);
	
		for (i = 0; args[i] != NULL; i++)
			free(args[i]);

	}

	free(command);
	free(raw_user_input);
	free(args);

	return (0);
}
#include "utils.h"
#include <stdlib.h>
#include <string.h>

/**
 * get_args - Tokenize an input string and create an array of arguments.
 * @input: The input string to tokenize.
 *
 * This function tokenizes the input string based on spaces and stores each
 * token as a separate element in an array of strings. The memory for the
 * array and each argument is dynamically allocated.
 *
 * Return: A dynamically allocated array of argument strings, terminated
 * with NULL. If memory allocation fails, returns NULL.
 */

char **get_args(char *input)
{
	char **args = malloc(MAX_ARGS_LEN * sizeof(char *));
	char *current = strtok(input, " ");

	int i = 0;

	while (current != NULL && i < MAX_ARGS_LEN)
	{
		args[i] = strdup(current);
		current = strtok(NULL, " ");
		i++;
	}

	args[i] = NULL;

	free(current);
	return (args);
}


/**
 * _printstr - Print a string to stdout.
 * @str: The string.
 *
 * Return: 0
 */

void _printstr(const char *str)
{
	write(STDOUT_FILENO, str, strlen(str));
}

/**
 * read_input - A function that receives and reads user's input.
 * @command: The string input from the user.
 * @size: The size allocated to input received.
 * Return: Using the exit MACRO in place of returns.
 */

void read_input(char *command, size_t size)
{
	if (isatty(STDIN_FILENO))
		_printstr("$ ");

	if (fgets(command, size, stdin) == NULL)
	{
		if (feof(stdin))
		{
			/* _printstr("\n"); */
			exit(EXIT_SUCCESS);
		}
		else
		{
			_printstr("Error while reading input.\n");
			exit(EXIT_FAILURE);
		}
	}

	if (strncmp(command, "exit", 4) == 0)
	{
		errno = 2;
		exit(EXIT_SUCCESS);
	}

	command[strcspn(command, "\n")] = '\0';
}

/**
* prepare - Prepares a command for execution by
* prepending its path
*
* @command: The command.
*
* Return: void
*/
char *prepare(char *command)
{
	char *path = get_path();
	char *token = malloc(strlen(path));
	char *file = malloc(strlen(path) + strlen(command) + 1);
	char *path_cpy = strdup(path);
	int found = 0;

	token = strtok(path_cpy, ":");

	while (token != NULL)
	{
		char buffer[MAX_CMD_LEN];

		if (strncmp(token, command, strlen(token)) == 0)
		{
			/* in this case, we just use the command directly */
			strcpy(file, command);
		}
		else
		{
			strcpy(buffer, token);
			strcat(buffer, "/");


			strcpy(file, buffer);
			strcat(file, command);
		}

		if (access(file, F_OK) == 0)
		{
			return (file);
			found = 1;
		}

		token = strtok(NULL, ":");
	}

	free(token);
	free(file);
	free(path_cpy);
	/*free(path);*/

	if (found == 1)
		return (command);
	else
		return (NULL);
}


/**
 * get_path - Returns the PATH.
 *
 * Return: The PATH environment variable as a string.
 */
char *get_path(void)
{
	int i = 0;

	while (environ[i] != NULL)
	{
		if (strncmp(environ[i], "PATH=", 5) == 0)
			return (environ[i] + 5);
		i++;
	}

	exit(EXIT_FAILURE);
}
